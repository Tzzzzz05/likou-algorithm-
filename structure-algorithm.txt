



## 数组

![数组总结](D:\桌面\likou-algorithm-\structure-algorithm.assets\数组总结-1697901933676-1.png)

### 力扣27题-[移除元素](https://leetcode.cn/problems/remove-element/)

详细讲解请移步：[代码随想录 ](https://www.programmercarl.com/0027.移除元素.html#算法公开课)

#### 第一种写法：暴力解法

``` c++
//时间复杂度是O(n^2)
#icnlude<iostream>
using namespace std;
//使用俩个循环来进行，当在数组中找到一个target后，将用一个内循环其后面的每一个元素向前推一个位置。
int fun(vector<int>&nums,int target)
{
    int size=nums.size();
    for(int i=0;i<nums.size();i++)
    {
        if(nums[i]==target)
        {
            for(int j=i+1;j<size;j++)
        {
            nums[j-1]=nums[j];
			
		}
            //因为“删除”一个target，所以数组长度减一
            size--;
            /*因为“删除”一个target后，还需要判断新上位的那个元素是
            不是target，所以需要将其i--*/
            i--;
            
        }
    }
    return size;//返回数组最终长度
    
}

int main()
{
    vector<int>nums={1,2,3,4,5,6,7,8,100,99};
    int target;
    cin>>target;
    cout<<fun(nums,target);
}
```

#### 第二种方法：双指针法

```c++
//时间复杂度是O(n)
#icnlude<iostream>
#include<vector>
using namespace std;

int fun(vector<int>&nums,int target)
{
    int slow=0;
    int size=nums.size();
    for(int fast=0;fast<size;fast++)
    {
        if(nums[fast]!=target)
        {
            nums[slow]=nums[fast];
            slow++;
        }
        
    }
    return slow;
}


int main()
{
    vector<int>nums={1,2,3,4,5,6,7,8,100,99};
    int target;
    cin>>target;
    cout<<fun(nums,target);
}
```



***



### 力扣977题-[有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

详细讲解请移步：[代码随想录](https://www.programmercarl.com/0977.有序数组的平方.html)

#### 第一种写法：暴力解法

```c++
//部分代码//时间复杂度是 O(n + nlogn)
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        for (int i = 0; i < A.size(); i++) {
            A[i] *= A[i];
        }
        sort(A.begin(), A.end()); // 快速排序,时间复杂度为O(nlo)
        return A;
    }
};
```



#### 第二种写法：双指针法

```c++
//时间复杂度是 O(n)
#include<iostream>
#include<vector>
using namespace std;
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) { //此函数返回一个vector<int>动态数组
        vector<int>result(nums.size(), 0);  //（nums.size(), 0）新建一个大小为nums.size()，元素都为0的动态数组
        int sizes = nums.size()-1;
        
        for (int left = 0,right = nums.size() - 1; left <= right;)//使用一个循环，来进行双指针移动操作
        {
            if (nums[left] * nums[left] > nums[right] * nums[right])
            {
                result[sizes] = nums[left] * nums[left];
                sizes--;//这里可以合并简化为result[sizes--] = nums[left] * nums[left];
                left++;
            }
            else {
                result[sizes] = nums[right] * nums[right];
                sizes--;
                right--;
            }
        }
        return result;
    }
};

int main()
{
    Solution mvp;
    vector<int>nums = { -12,-4,-3,0,4,10,11 };
    nums=mvp.sortedSquares(nums);
    for (int element : nums) {
        cout << element << " ";
    }


}
```



***



### 力扣209题-[长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

详细讲解请移步：[代码随想录 ](https://www.programmercarl.com/0209.长度最小的子数组.html#算法公开课)

#### 第一种写法：滑动窗口

```c++
//
#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum=0;	//滑动窗口数值之和
        int i=0;	//滑动窗口起始位置
        int result=INT32_MAX; 
        //这个INT32_MAX是一个宏，是32位的最大值，即 2147483647

        for(int j=0;j<nums.size();j++)
        {
            sum+=nums[j];
            while(sum>=target)
            {
                int nowlong=j-i+1;	// 取子序列的长度
                result=min(nowlong,result);
                sum=sum-nums[i];
                // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
                i++;
            }

        }
		//如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result==INT32_MAX?0:result;


    }
};
int main()
{
    vector<int>nums={2,3,1,2,4,3};

    Solution A;
    int result=A.minSubArrayLen(8,nums);
    cout<<result<<endl;

}
```



#### 第二种写法：暴力法

```c++
#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result=INT32_MAX;	// 最终的结果
        int newlong=0;	// 子序列的数值之和
        int sum=0;	
        for(int i=0;i<nums.size();i++)// 设置子序列起点为i
        {
        sum=0;
          for(int j=i;j<nums.size();j++)// 设置子序列终止位置为j
         {
          sum+=nums[j];
          newlong=j-i+1;
          if(sum>=target)
          {
            result=min(result,newlong);
            break;// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break
          }
            
         }
    }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
      return result==INT32_MAX ? 0:result;

    }
};
int main()
{
    vector<int>nums={2,3,1,2,4,3};

    Solution A;
    int result=A.minSubArrayLen(7,nums);
    cout<<result<<endl;

}
```

































