



## 数组

<img src="D:\力扣算法题\likou-algorithm-\structure-algorithm.assets\数组总结.png" alt="img" style="zoom:200%;" />





### 力扣27题-[移除元素](https://leetcode.cn/problems/remove-element/)

详细讲解请移步：[代码随想录 ](https://www.programmercarl.com/0027.移除元素.html#算法公开课)

#### 第一种写法：暴力解法

``` c++
//时间复杂度是O(n^2)
#icnlude<iostream>
using namespace std;
//使用俩个循环来进行，当在数组中找到一个target后，将用一个内循环其后面的每一个元素向前推一个位置。
int fun(vector<int>&nums,int target)
{
    int size=nums.size();
    for(int i=0;i<nums.size();i++)
    {
        if(nums[i]==target)
        {
            for(int j=i+1;j<size;j++)
        {
            nums[j-1]=nums[j];
			
		}
            //因为“删除”一个target，所以数组长度减一
            size--;
            /*因为“删除”一个target后，还需要判断新上位的那个元素是
            不是target，所以需要将其i--*/
            i--;
            
        }
    }
    return size;//返回数组最终长度
    
}

int main()
{
    vector<int>nums={1,2,3,4,5,6,7,8,100,99};
    int target;
    cin>>target;
    cout<<fun(nums,target);
}
```

#### 第二种方法：双指针法

```c++
//时间复杂度是O(n)
#icnlude<iostream>
#include<vector>
using namespace std;

int fun(vector<int>&nums,int target)
{
    int slow=0;
    int size=nums.size();
    for(int fast=0;fast<size;fast++)
    {
        if(nums[fast]!=target)
        {
            nums[slow]=nums[fast];
            slow++;
        }
        
    }
    return slow;
}


int main()
{
    vector<int>nums={1,2,3,4,5,6,7,8,100,99};
    int target;
    cin>>target;
    cout<<fun(nums,target);
}
```



### 力扣977题-[有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

详细讲解请移步：[代码随想录](https://www.programmercarl.com/0977.有序数组的平方.html)

#### 第一种写法：暴力解法

```c++
//部分代码//时间复杂度是 O(n + nlogn)
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        for (int i = 0; i < A.size(); i++) {
            A[i] *= A[i];
        }
        sort(A.begin(), A.end()); // 快速排序,时间复杂度为O(nlo)
        return A;
    }
};
```



#### 第二种写法：双指针法

```c++
//时间复杂度是 O(n)
#include<iostream>
#include<vector>
using namespace std;
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) { //此函数返回一个vector<int>动态数组
        vector<int>result(nums.size(), 0);  //（nums.size(), 0）新建一个大小为nums.size()，元素都为0的动态数组
        int sizes = nums.size()-1;
        
        for (int left = 0,right = nums.size() - 1; left <= right;)//使用一个循环，来进行双指针移动操作
        {
            if (nums[left] * nums[left] > nums[right] * nums[right])
            {
                result[sizes] = nums[left] * nums[left];
                sizes--;//这里可以合并简化为result[sizes--] = nums[left] * nums[left];
                left++;
            }
            else {
                result[sizes] = nums[right] * nums[right];
                sizes--;
                right--;
            }
        }
        return result;
    }
};

int main()
{
    Solution mvp;
    vector<int>nums = { -12,-4,-3,0,4,10,11 };
    nums=mvp.sortedSquares(nums);
    for (int element : nums) {
        cout << element << " ";
    }


}
```















































